org.springframework.beans.factory.support.AbstractBeanFactory.transformedBeanName
通过name获得beanName,不是用name直接作为beanName主要有两个原因
1、name可能会以&开头，表示调用者想获得FactoryBean本身，而不是FactoryBean生产出来的bean。
   在BeanFactory的beanDefinitionMap中，FactoryBean以<beanName,bean>的格式存储，而beanName不含有&字符。
   因此需要将&从name中移除，才能获取到bean
2、别名问题，@AliasFor

spring bean的扫描
1、org.springframework.context.annotation.AnnotationConfigApplicationContext.AnnotationConfigApplicationContext()
-->this.reader = new AnnotatedBeanDefinitionReader(this);
完成了spring内置beanDefinition的扫描（spring开天辟地的类）
2、org.springframework.context.annotation.AnnotationConfigApplicationContext.register(componentClasses)
完成了手动传给spring的类的扫描,即被加到beanDefinitionMap中.
3、org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors
-->org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors
-->org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors
完成了自定义类的beanDefinition扫描（即，被componentScan的类）以及执行beanFactory后置处理器。
执行这句之前，beanFactory中的beanDefinitionMap中只有spring内置的beanDefinition，以及通过构造参数传给spring的配置类
执行这句之后，自定义对象也变成beanDefinition被加入到beanDefinitionMap中了。
4、注意：
第一，在扫描beanDefinition时，会解析是否时全注解类，即是否有@Configuration注解，并做标识
先解析配置类，再扫描业务类，再解析业务类
org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors
-->org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions
第二，在beanDefinition被加到beanDefinitionMap中后，还会检查他们是否是“全注解类”，如果是，则会用cglib代理，否则则是普通bean。
org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors
-->org.springframework.context.annotation.ConfigurationClassPostProcessor.enhanceConfigurationClasses
第三，invokeBeanFactoryPostProcessors的作用：执行spring内部和程序员提供的beanFactoryPostProcessor
spring内部的beanFactoryPostProcessor-->完成了自定义类的beanDefinition扫描
程序员提供的beanFactoryPostProcessor-->扩展点

org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization
其中调用preInstantiateSingletons方法，先验证beanDefinition（是否单例，是否懒加载，等等）
验证通过后，调用getBean实例化单例bean

org.springframework.beans.factory.support.AbstractBeanFactory#transformedBeanName
验证bean的name是否合法

org.springframework.beans.factory.support.AbstractBeanFactory#resolveBeanClass
从beanDefinition对象中获取bean的类型

@autowired和autowiring的区别 https://www.jianshu.com/p/3c7e0608ff1f

spring在createBean中9次执行后置处理器（后置处理器可以插手bean的实例化、初始化过程）
1、实例化之前
org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation
	org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInstantiation
		org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation
	org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization
		org.springframework.beans.factory.config.BeanPostProcessor#postProcessAfterInitialization
2、推断构造函数（由后置处理器决定访问哪些构造方法）
org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#determineConstructorsFromBeanPostProcessors
	org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor#determineCandidateConstructors
3、合并BeanDefinition
org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors
	org.springframework.beans.factory.support.MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition
4、解决循环引用，加入二级缓存时用的
org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#getEarlyBeanReference
	org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference
5、6、注入属性时
org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean
	org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation（是否注入属性扩展点）
	org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor#postProcessPropertyValues（如果continueWithPropertyPopulation为true，注入属性）
7、8、初始化方法（生命周期回调方法， InitializingBean @PostConstructor）
org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean
    org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeAwareMethods（执行部分Aware，BeanNameAware、BeanClassLoaderAware、BeanFactoryAware）
	org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization
		org.springframework.beans.factory.config.BeanPostProcessor#postProcessBeforeInitialization（执行@PostConstruct、ApplicationContextAware）
	org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization（完成代理）
		org.springframework.beans.factory.config.BeanPostProcessor#postProcessAfterInitialization
	注意：
	org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#invokeInitMethods（执行InitializingBean）
9、销毁(@PreDestroy,DisposableBean)
CommonAnnotationBeanPostProcessor

如何把一个对象交给spring管理（第三方提供的bean可能沒有生命周期，lifecircle包做了以下情况的实验）
@bean（有） registerSingleton（沒有） factorybean（没有） factorymethod（静态工厂法（有）、实例工厂法（有））

如何产生一个对象
new 反射 clone 序列化

