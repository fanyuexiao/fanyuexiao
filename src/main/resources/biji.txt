org.springframework.beans.factory.support.AbstractBeanFactory.transformedBeanName
通过name获得beanName,不是用name直接作为beanName主要有两个原因
1、name可能会以&开头，表示调用者想获得FactoryBean本身，而不是FactoryBean生产出来的bean。
   在BeanFactory的beanDefinitionMap中，FactoryBean以<beanName,bean>的格式存储，而beanName不含有&字符。
   因此需要将&从name中移除，才能获取到bean
2、别名问题，@AliasFor
3、对name的合法性验证

beanDefinitionHolder的作用：其实没什么用，为了别名，@AliasFor，对beanDefinition做了个封装

org.springframework.context.support.AbstractApplicationContext#finishBeanFactoryInitialization
其中调用preInstantiateSingletons方法，先验证beanDefinition（是否单例，是否懒加载，等等）
验证通过后，调用getBean实例化单例bean

org.springframework.beans.factory.support.AbstractBeanFactory#transformedBeanName
验证bean的name是否合法

org.springframework.beans.factory.support.AbstractBeanFactory#resolveBeanClass
从beanDefinition对象中获取bean的类型

@autowired和autowiring的区别 https://www.jianshu.com/p/3c7e0608ff1f

spring在createBean中9次执行后置处理器（后置处理器可以插手bean的实例化、初始化过程）
1、实例化之前
org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation
	org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInstantiation
		org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation
	org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization
		org.springframework.beans.factory.config.BeanPostProcessor#postProcessAfterInitialization
2、推断构造函数（由后置处理器决定访问哪些构造方法）
org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#determineConstructorsFromBeanPostProcessors
	org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor#determineCandidateConstructors
3、合并BeanDefinition
org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors
	org.springframework.beans.factory.support.MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition
4、解决循环引用，加入二级缓存时用的
org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#getEarlyBeanReference
	org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference
5、6、注入属性时
org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean
	org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation（是否注入属性扩展点）
	org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor#postProcessPropertyValues（如果continueWithPropertyPopulation为true，注入属性）
7、8、初始化方法（生命周期回调方法， InitializingBean @PostConstructor）
org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean
    org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeAwareMethods（执行部分Aware，BeanNameAware、BeanClassLoaderAware、BeanFactoryAware）
	org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization
		org.springframework.beans.factory.config.BeanPostProcessor#postProcessBeforeInitialization（执行@PostConstruct、ApplicationContextAware）
	org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsAfterInitialization（完成代理）
		org.springframework.beans.factory.config.BeanPostProcessor#postProcessAfterInitialization
	注意：
	org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#invokeInitMethods（执行InitializingBean）
9、销毁(@PreDestroy,DisposableBean)
CommonAnnotationBeanPostProcessor

如何把一个对象交给spring管理（第三方提供的bean可能沒有生命周期，lifecircle包做了以下情况的实验）
@bean（有） registerSingleton（沒有） factorybean（没有） factorymethod（静态工厂法（有）、实例工厂法（有））
registerSingleton：动态数据源，注射多个datasource时用到

如何产生一个对象
new 反射 clone 序列化

单例依赖多例的解决方法
ApplicationContextAware、@Lookup

lifecycle callback
1、bean的lifecycle callback(初始化、销毁)
@postConstructor --> initializingBean --> <init-method="">
2、spring容器的lifecycle callback（启动、销毁）
Lifecycle、SmartLifecycle

接口（多个实现）注入
xml手动装配、@Autowired属性名、@Qualifer